---
title: Narrowing
description: محدود کردن نوع متغیر به یک نوع خاص تر بر اساس بررسی های منطقی
createdAt: 2025/08/24
updatedAt: 2025/08/26
---

در تایپ اسکریپت، `Narrowing` به فرآیندی گفته می‌شود که در آن نوع (type) یک مقدار از یک حالت کلی‌تر (مثل string | number) به حالتی خاص‌تر (مثل فقط string یا فقط number) محدود می‌شود، تا بتوانیم با اطمینان از ویژگی‌های آن نوع استفاده کنیم.

```ts
// Ex:
function printPadding(padding: string | number) {
   if (typeof padding === "string") {
     // اینجا padding فقط یک رشته است
     console.log(padding.toUpperCase());
   } else {
     // اینجا padding فقط یک عدد است
     console.log(padding.toFixed(2));
   }
 }
```

## typeof type guards
تمام نوع های زیر توسط عملگر `typeof` پشتیبانی می شوند. این عملگر نوع یک مقدار را به صورت رشته‌ای بر می‌گرداند.

-   string
-   number
-   bigint
-   boolean
-   symbol
-   undefined
-   object
-   function
    
این نکته را مدنظر داشته باشید که نوع مقدار `null` و`Array` در جاوا اسکریپت `object` است
عملگر هایی مانند `==` ، `===` ، `!=` ، `!==` و دستور `switch` کمک می کنند که نوع یک مقدار در یک بلوک خاص مشخص شود.

## Truthiness narrowing
در جاوااسکریپت هر مقدار در موقعیت هایی مانند `if`، `&&`، `||`، `!` که مقدار `boolean` لازم هست، به `true` یا `false` تبدیل می‌شود. به این ویژگی **truthiness** می‌گویند.

```ts
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

در جاوااسکریپت، ساختارهای شرطی مثل `if` ابتدا مقدار شرط را به `boolean` تبدیل می‌کنند (coercion) و سپس مسیر اجرایی را بر اساس `true` یا `false` انتخاب می‌کنند.

مقادیر زیر در شرط بالا به `false` تبدیل می‌شوند و بقیهٔ مقادیر به `true`:

- 0
- NaN
- "" (رشتهٔ خالی)
- 0n (صفر از نوع bigint)
- null
- undefined

می‌توانید با تابع `Boolean` یا با دو عملگر نقیض `!!` این تبدیل را صراحتاً انجام دهید.(پیشنهاد می‌شود روش دوم را استفاده کنید تا تایپ اسکریپت نوع آن را دقیقا تشخیص دهد)

```js
Boolean("hello"); // مقدار: true,  نوع: boolean,       مقادیر مجاز: true یا false
!!"world";        // مقدار: true,  نوع: literal true,  مقادیر مجاز: true
```

استفاده از این رفتار بسیار رایج است، به‌ویژه برای کنترل مقادیر `null` یا `undefined`. به عنوان مثال تابع `printAll` را با این روش می‌نویسیم:

```ts
function printAll(strs: string | string[] | null) {
  if (strs && typeof strs === "object") {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

با بررسی truthiness بودن `strs`، از خطای `TypeError: null is not iterable` جلوگیری کردیم. اما کنترل truthiness بودن مقادیر می‌تواند خطا هم داشته باشد. به مثال زیر دقت کنید:

```ts
function printAll(strs: string | string[] | null) {
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs);
    }
  }
}
```

تمام کد ها را در `if` `truthiness`  قرار دادیم. مشکل اینجاست که یک رشته خالی چون `truthy` نیست، چاپ نمی شود.

## The  `in`  operator narrowing
این عملگر وجود یک پراپرتی را در type مدنظر بررسی می کند، و true یا false را بر می گرداند.

در مثال زیر بررسی شده است که آیا پراپرتی `swim` در object `animal` وجود دارد یا خیر. با این کار مشخص می شود که داخل بلوک `if` ، object `animal` از نوع `Fish` است و به پس بنابراین میتوان گفت که عملیات narrowing در این قسمت انجام شده است.

```typescript
  type Fish = { swim: () => void };
  type Bird = { fly: () => void };
   
  function move(animal: Fish | Bird) {
    if ("swim" in animal) {
      return animal.swim();
    }
   
    return animal.fly();
  }
```

## instanceof narrowing
 در جاوا اسکریپت عملگر `instanceof` بررسی می‌کند که مقدار مورد نظر، نمونه ای از نوع مشخص شده هست یا نه.
 
  در مثال زیر ، جاوااسکریپت، `x instanceof Foo` بررسی می‌کند که آیا `x` نمونه‌ای از `Foo` است یا نه. در TypeScript، این بررسی به TypeScript کمک می‌کند تا نوع `x` را درون بلاک `if` محدودتر کند.

```typescript
  function logValue(x: Date | string) {
    if (x instanceof Date) {
      // x به عنوان Date شناخته شده و متدهای Date در دسترس‌اند
      console.log(x.toUTCString());
    } else {
      // x به عنوان string شناخته شده
      console.log(x.toUpperCase());
    }
  }
```

## Assignments
تایپ اسکریپت همیشه هنگام مقدار دهی های بعدی متغیر ها ، بررسی می‌کند که مقدار اختصاص یافته به آن، با نوع اصلی متغیر هنگام تعریفش مطابقت دارد یا نه.

```typescript
  let x = Math.random() < 0.5 ? 10 : "hello world!";
  
  x = 1;
  x = "goodbye!";
  x = true;  // در این قسمت از کد خطا ارسال میشود. چون که متغیر x فقط میتواند مقادیر number و string را قبول کند
```

## control flow analysis
تایپ اسکریپت فقط به یک شرط نگاه نمی‌کند بلکه کل جریان منطقی اجرا را نگاه می‌کند (مانند return, if-else, switch-case, break, continue...) تا در هر موقعیتی دقیق ترین نوع مقدار یا متغیر را تشخیص دهد.

## using type predicate
**Type Predicate** در تایپ اسکریپت عبارتی است که به کامپایلر می‌گوید اگر یک تابع مقدار `true` برگرداند، نوع یک متغیر را به‌صورت دقیق‌تر (narrowed) در نظر بگیرد. یعنی بعد از `return true`, نوع بازگشتی تابع  ، نوعی است که در type predicate مشخص شده است.

```typescript
  function functionName(param: SomeType): param is NarrowedType {
    // logic to check if param is NarrowedType
}
```

به مثال زیر توجه کنید:

```typescript
  interface Car {
    drive: () => void;
    wheels: number;
  }
  
  interface Bike {
    pedal: () => void;
    wheels: number;
  }
  
  // این قسمت مهم‌ترین بخش است: type predicate. یعنی اگر این تابع true برگرداند، TypeScript می‌فهمد که vehicle از نوع Car است.
  function isCar(vehicle: Car | Bike): vehicle is Car {
    // این یک بررسی ساده است: اگر ویژگی drive در vehicle وجود داشته باشد، پس حتماً vehicle از نوع Car است. چون فقط Car این ویژگی را دارد.
    return (vehicle as Car).drive !== undefined;
  }
  
  // استفاده از آن
  function useVehicle(vehicle: Car | Bike) {
    if (isCar(vehicle)) {
      vehicle.drive(); // اینجا vehicle از نوع Car است
    } else {
      vehicle.pedal(); // اینجا vehicle از نوع Bike است
    }
  }
```

## Exhaustiveness checking
در تایپ اسکریپت ، بررسی کامل (exhaustiveness checking) به ما کمک می کند که مطمئن شویم در یک ساختار کنترلی مانند `switch` همه حالت ها برای یک نوع `union` کنترل شود.

```typescript
  type Shape = 
    | { kind: "circle"; radius: number }
    | { kind: "square"; sideLength: number };
  
  function getArea(shape: Shape): number {
    switch (shape.kind) {
      case "circle":
        return Math.PI * shape.radius ** 2;
      case "square":
        return shape.sideLength ** 2;
      default:
        // اگر همه‌ی حالت‌ها بررسی شده باشند، shape از نوع never خواهد بود
        const _exhaustiveCheck: never = shape; // اگر حتی یک حالت جا مانده باشد، خطا می‌دهد
        return _exhaustiveCheck;
    }
  }
```

