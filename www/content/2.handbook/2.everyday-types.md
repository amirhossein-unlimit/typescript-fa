---
title: انواع متداول تایپ ها
description: استفاده از انواع داده‌ های پرکاربرد در تایپ اسکریپت
createdAt: 2025-08-13
---

## The Primitives

سه تایپ `string`، `number` و `boolean` از همه متداول تر اند و در TypeScript و JavaScript یکسان هستند.

## Array

برای تعریف آرایه‌ای از هر نوع مقدار استفاده می‌شود. انواع روش‌های تعریف تایپ از نوع آرایه:

```typescript
// --- syntax 1
// ex: 1. array of numbers
let numbers: number[] = [1, 2, 3];
// ex: 2. array of strings
let names: string[] = ["Ali", "Reza"];

// --- syntax 2
// ex: 1. array of numbers
let numbers: Array<number> = [1, 2, 3];
// ex: 2. array of strings
let names: Array<string> = ["Ali", "Reza"];
```

## Any

هرگز پیشنهاد نمی شود از این نوع استفاده کنید زیرا هر نوع داده ای را مجاز می کند و عملاً حضور TypeScript را بی تأثیر می‌کند. این نوع زمانی استفاده می شود که TypeScript نوع داده ای را تشخیص نمی دهد یا نوع داده مدنظر نامشخص است.

```typescript
const chartConfig: any = {
  title: "Sales Chart",
  data: [10, 20, 30],
  colors: ["red", "green", "blue"],
  animation: true
};

oldChartLibrary(chartConfig);
```

## Type Annotations

زمانی که از `var`، `const` یا `let` برای تعریف متغیر استفاده می کنیم، می توانیم یک توضیح نوع به آن اضافه کنیم تا نوع متغیر به صورت کاملاً صریح مشخص شود و خوانایی کد بالاتر برود.

```typescript
// ex: 1. variable with number type
let age: number = 25;

// ex: 2. variable with string type
let name: string = "Sara";

// ex: 3. variable with boolean type
let isActive: boolean = true;

// ex: 4
let data: null = null;

// ex: 5
let value: undefined = undefined;
```

::alert{type="secondary" icon="lucide:info"}
  زمانی که متغیر را مقداردهی می‌کنیم، نوع آن به صورت کاملاً صریح برای TypeScript مشخص است. بنابراین در این مواقع نیازی به نوشتن توضیح نوع نیست و انجام این کار باعث طولانی‌تر شدن کد می‌شود.
::

## Function

در TypeScript می‌توانیم نوع پارامتر ها و خروجی تابع را مشخص کنیم.

```typescript
function greetUser(name: string): string {
  return `سلام ${name}! خوش آمدی.`;
}
```

### Functions Which Return Promises

مشخص کردن نوع توابعی که خروجی آن‌ها به صورت یک Promise است:

```typescript
function fetchData(data: string): Promise<string> {
  return new Promise((resolve, reject) => {
    // Simulate a 2-second delay
    setTimeout(() => {
      if (data) {
        resolve(`داده دریافت شد: ${data}`);
      } else {
        reject(new Error("داده ورودی خالی است!"));
      }
    }, 2000);
  });
}
```

### Anonymous Function

TypeScript می تواند نوع ورودی های تابع ناشناس را بسته به موقعیت مورد استفاده تشخیص دهد.

در مثال زیر، TypeScript نوع ورودی `name` را به دلیل اینکه `names` آرایه‌ای از رشته‌ها است و متد `forEach` هم قرار است که تک تک این رشته‌ها را به تابع ناشناس ارسال کند، تشخیص می‌دهد:

```typescript
const names = ["Alice", "Bob", "Eve"];

// ex: 1
// Contextual typing for function - parameter s inferred to have type string
names.forEach(function(name) {
  console.log(name.toUpperCase());
});

// ex: 2
// Contextual typing also applies to arrow functions
names.forEach((name) => {
  console.log(name.toUpperCase());
});
```

## Object Types

برای تعریف نوع یک Object در برنامه باید از کلمه `interface` استفاده کنیم. می‌توانیم پراپرتی‌ها را با `,` یا `;` از یکدیگر جدا کنیم.

در مثال زیر، نوع ورودی `pt` که یک Object است، در همان زمان تعریف نوشته شده است:

```typescript
// --- syntax 1
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });


// --- syntax 2
interface Pt {
  x: number;
  y: number;
}

function printCoord(pt: Pt) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}
printCoord({ x: 3, y: 7 });
```

### Optional Property

برای ایجاد یک پراپرتی اختیاری، باید بعد از نام پراپرتی و قبل از `:`، علامت `?` را قرار دهیم:

```typescript
function printName(obj: { first: string; last?: string }) {
  // ...
}

// ex: 1
printName({ first: "Bob" });
// ex: 2
printName({ first: "Alice", last: "Alisson" });
```

::alert{type="warning" icon="lucide:triangle-alert"}
  برای استفاده ایمن تر از پارامتر های اختیاری باید آنها را بررسی کنیم که `undefined` نباشند.
::

```typescript
function printName(obj: { first: string; last?: string }) {
  console.log(obj.last?.toUpperCase());
}
```

## Union Type

به ما این امکان را می‌دهد که یک ورودی یا متغیر را به گونه‌ای تعریف کنیم که شامل دو یا چند نوع باشد. وقتی یک متغیر از نوع `union` تعریف می‌شود، فقط می‌توان عملیات‌هایی روی آن انجام داد که برای هر دو نوع تعریف شده، قابل انجام باشد.

در مثال پایین ورودی `id` می‌تواند رشته‌ای یا عددی باشد. از متدهایی می‌توان استفاده کرد که هم برای نوع `number` و هم `string` در دسترس باشند.

برای اینکه بتوانیم از متدهای مخصوص به هر کدام استفاده کنیم و از تایپ اسکریپت هم خطا دریافت نکنیم، باید استفاده از آنها را مشروط به نوع آن کنیم. به این کار `Type Narrowing` گفته می‌شود. در این مثال متدهای مربوط به رشته در شرط `typeof id === "string"` و متدهای مربوط به اعداد در `else` در دسترس خواهند بود.

```typescript
function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```